#include "spotify_ll.h"
#include "spotify_structs.h"

static struct 
song_info_node *head = NULL;

static struct 
available_song_node *available_node = NULL;

static struct 
spotify_playlist *available_playlist_node = NULL;

static struct 
spotify_playlist_songs *available_playlist_song_node = NULL;

 /*
 * insert the node, its a linked list, but if you dont know,
 * when we create a new node, we want the head pointer to point to it
 * so have the previous head point to head, then we have head point to the new one
 * @param song_info - the parsed string of the song info
 * @param size - the size of the string, used for malloc size
 * @note, we allocate in the heap because we want each parsed bit of info
 * into its own node instead of sharing the same memory address
 */
void 
insert_node(char* song_info, ssize_t size) 
{
  struct song_info_node *node = (struct song_info_node*) malloc(sizeof(struct song_info_node));

  char *dest = malloc(sizeof(char) * size);

  /* copy the info into a new address space */
  memcpy(dest, song_info, size);

  /* have the node point to it */
  node->data = dest;

  /* point to previous head */
  node->next = head;

  /* new head */
  head = node;
}

/**
 * insert into the linked list of available songs
 * @param album_info - the id of the album
 * @param artist_info - artist name for display purposes
 * @param track_position - the position of the song in the album
 * @param song_info - song title for display purposes
 */
void 
insert_search_node(struct available_song_node *node) 
{
  /* point to previous head */
  node->next = available_node;

  /* new head */
  available_node = node;
}

/**
 * insert into the linked list of available songs
 * @param album_info - the id of the album
 * @param artist_info - artist name for display purposes
 * @param track_position - the position of the song in the album
 * @param song_info - song title for display purposes
 */
void 
insert_playlist_node(struct spotify_playlist *node) 
{
  /* point to previous head */
  node->next = available_playlist_node;

  /* new head */
  available_playlist_node = node;
}

/**
 * insert into the linked list of available songs
 * @param album_info - the id of the album
 * @param artist_info - artist name for display purposes
 * @param track_position - the position of the song in the album
 * @param song_info - song title for display purposes
 */
void 
insert_playlist_song_node(struct spotify_playlist_songs *node) 
{
  /* point to previous head */
  node->next = available_playlist_song_node;

  /* new head */
  available_playlist_song_node = node;
}

/**
 * prints all the nodes strings, has the parantheses wrapping
 * around them
 */
void printList() {
  struct song_info_node *ptr = head;

  while(ptr != NULL) {
    printf("(%s) ",ptr->data);
    ptr = ptr->next;
  }
	
   printf("\n");
}

static void reverse(struct spotify_playlist_songs** head_ref)
{
  struct spotify_playlist_songs* prev = NULL;
  struct spotify_playlist_songs* current = *head_ref;
  struct spotify_playlist_songs* next = NULL;

  while (current != NULL) 
  {
    /* Store next */
    next = current->next;

    /* Reverse current node's pointer */
    current->next = prev;

    /* Move pointers one position ahead. */
    prev = current;
    current = next;
  }

  *head_ref = prev;
}

/**
 * prints all the nodes strings, has the parantheses wrapping
 * around them
 */
u_int8_t print_playlist_songs() {
  struct spotify_playlist_songs *ptr = available_playlist_song_node;
  reverse(&ptr);

  u_int8_t counter = 0;

  while(ptr != NULL) {
    printf("%s[%d]%s %s%s%s (%s%s%s) by %s%s%s\n",
	   "\x1B[36m",counter++,"\x1B[0m",
	   "\x1B[31m",ptr->playlist_song_name,"\x1B[0m",
	   "\x1B[34m",ptr->playlist_song_album,"\x1B[0m",
	   "\x1B[33m",ptr->playlist_artist_name,"\x1B[0m");
    ptr = ptr->next;
  }

  /* ask what song we want to play*/
  int choice;

  printf("\nPlay which song? ");

  while(true)
  {
    scanf("%d", &choice);
    if(!(choice > -1 && choice < counter )) {
      printf("\nplease enter the a valid range: ");
    } else
      break;
  }

   return choice;
}
/**
 * prints all the nodes strings, has the parantheses wrapping
 * around them
 */
char *print_playlist() {
  struct spotify_playlist *ptr = available_playlist_node; 

  u_int8_t counter = 0;

  while(ptr != NULL) {
    printf("%s[%d]%s (%s) by %s\n",
	   "\x1B[36m",counter++,"\x1B[0m",
	   ptr->playlist_name,
	   ptr->playlist_owner);
    ptr = ptr->next;
  }

  /* ask what song we want to play*/
  int choice;

  printf("\nwhich playlist? ");

  while(true)
  {
    scanf("%d", &choice);
    if(!(choice > -1 && choice < counter )) {
      printf("\nplease enter the a valid range: ");
    } else
      break;
  }

  counter = 0;
  ptr = available_playlist_node;
  while(ptr != NULL) {
    if(counter == choice) {
      return ptr->playlist_uri;
      break;
    }

    counter++;
    ptr = ptr->next;
  }
	
   printf("\n");
   return NULL;
}

/**
 * prints all the available songs and then asks the user what
 * song to play based on index
 * around them
 */

struct search_song_request 
print_avaible_songs(u_int8_t MAX_SEARCH) 
{
  struct available_song_node *ptr = available_node;

  /* used to point to the node that we want album info from */
  u_int8_t counter = 0;

  /* params for play_song */
  /* char *album_id; */
  /* char *album_position; */

  struct search_song_request req_node;

  /* display available songs */
  while(ptr != NULL) {
    printf("%s[%d]%s %s%s%s (%s%s%s) by %s%s%s\n",
	   "\x1B[36m",counter++,"\x1B[0m",
	   "\x1B[31m",ptr->song_title,"\x1B[0m",
	   "\x1B[34m",ptr->album_name,"\x1B[0m",
	   "\x1B[33m",ptr->artist_info,"\x1B[0m");
    ptr = ptr->next;
  }

  /* reset so we can fetch the index position */
  ptr = available_node;
  counter = 0;
  
  /* ask what song we want to play*/
  int choice;
  printf("\nPlay which song? ");

  while(true)
  {
    scanf("%d", &choice);
    if(!(choice > -1 && choice < MAX_SEARCH )) {
      printf("\nplease enter the a valid range: ");
    } else
      break;
  }

  while(ptr != NULL) {
    if(counter == choice) {
      req_node.track_info = ptr->album_api_info;
      req_node.track_position = ptr->album_position;
      break;
    }

    counter++;
    ptr = ptr->next;
  }

  return req_node;
}

/**
 * frees all heap memory
 */

void 
clear_linked_list() 
{
  /* we dont want to mess with the actual head */
  struct song_info_node *ptr = head; 
  
  /* holds the node that will be deleted */
  struct song_info_node *temp; 

  /* as long as we are referencing something, do it */
  while(ptr) {
    /* free the data, or else it just sits there */
    free(ptr->data);

    /* poit to be deleted node, point to the next head, */
    /* then delete */
    temp = ptr;
    ptr = ptr->next;
    free(temp);
  }

  head = NULL;
}

/**
 * frees all heap memory
 */

void 
clear_search_list() 
{
  
  /* we dont want to mess with the actual head */
  struct available_song_node *ptr = available_node; 
  
  /* holds the node that will be deleted */
  struct available_song_node *temp; 

  /* as long as we are referencing something, do it */
  while(ptr) {
    /* free the data, or else it just sits there */
    free(ptr->album_api_info);
    free(ptr->album_position);
    free(ptr->artist_info);
    free(ptr->song_title);

    /* poit to be deleted node, point to the next head, */
    /* then delete */
    temp = ptr;
    ptr = ptr->next;
    free(temp);
  }

  available_node = NULL;
}
